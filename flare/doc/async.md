# 异步执行

高性能服务离不开异步执行机制。
在网络编程中，经常出现如下场景：编写特定逻辑服务器，该逻辑服务器依赖于后端的很多种服务器。比如需要获取多种服务数据，或者需要多个步骤。对于这样的应用，同步调用将导致逻辑服务器的吞吐量极低，异步调用是首选。

传统的异步服务器一般通过事件驱动机制，以回调函数、异步状态机等方式等实现其功能，代码往往复杂难以理解。我们通过 Fiber 和 Future 机制来简化异步代码的编写。可以阅读[代码对比](../doc/coding-comparison.md)获得更直观的印象。

## Fiber

在 Flare 中，RPC 客户端和服务器端的业务代码都在 Fiber 中执行，看起来是同步的，但是在某些特定的执行点会被框架挂起，其背后的执行线程会去执行其他就绪的 Fiber，从而实现用少量的线程调度大量的 Fiber 并发执行的效果。

还以[入门导引](intro-rpc.md)中的代码为例，当客户端发起 RPC 调用时：

```cpp
flare::Expected<EchoResponse, flare::Status> rc = stub.Echo(
    request, &controller);
```

在 `Echo` 函数内部，当前 Fiber 会被挂起，当前线程就可以执行其他处于就绪状态的 Fiber。直到收到回应或者超时，当前 Fiber 才重新被切换回来。

## 显式异步

用户还可以通过 Async 函数发起异步操作，该函数会在内部创建一个 Fiber 对象调度执行，并返回一个 [Futrue](future.md) 对象，调用端可以通过 Future 对象获取异步执行的结果。

---
[返回目录](README.md)
